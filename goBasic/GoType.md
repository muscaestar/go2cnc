# 类型
类型内容比较多，这里记录一些干Java的时候不会遇到的知识点

## 复数 complex
Go原生支持复数类型complex64，complex128。复数有两部分组成：`c = a + bi` 中，复数c的实数部分为a，虚数部分为b。复数只在矢量运算中会使用。

## 自定义类型、类型别名
```go
type newInt int // 自定义类型，底层类型是int
type aliasInt = int // 类型别名
type anotherInt aliasInt

var oneInt int = 1
res := aliasInt(1) == oneInt // true
newInt(1) == oneInt // 无法编译  (mismatched types newInt and int)
newInt(1) == newInt(anotherInt(1)) // 显式转换后再比较 true
```
- 上述例子中，newInt是一个基于int类型的新类型，无法直接与int型比较
- 类型别名指代的就是该类型，因此别名与原类型可以互相比较
- 只要底层类型相同，就可以显式转换

## 无类型常量
- 常量用`const`关键字申明，必须是在编译期就能确定具体的值
- 申明const时带有类型就是有类型常量
- go中可以在申明const时不带类型，编译器会给他默认类型
    - 无类型常量的**隐式转换**：编译器在处理无类型常量参与的表达式中，会尽可能做安全的转换
    - 如果编译器判定无类型常量的**隐式转换**不安全，会在编译期报错

## const块
- 有两个go特殊的东西：
    1. 隐式重复前一个非空表达式
    2. iota：值代表当前const块中当前常量的偏移量
- 因为有这个特性，const块可以用来申明枚举
- go没有定义enum类型，设计初便希望能将常量和枚举做在一起 
- 貌似是go中很常用的特性，读懂开源项目必须掌握

## 指针类型
- Java没有的东西
- Go的指针和C一样，不过加了一些限制
    1. Go中限制了指针类型转换`*int`不能转成`*byte`，C是可以的
        - 可以使用unsafe.Pointer方法强转
    2. Go中指针类型不能进行运算，C里可以的（用来实现一些hack操作）
        - 可以用unsafe.Pointer再加uintptr类型，组合实现指针运算
- 指针的基本知识：
    - 指针类型有**基类型**，比如指针类型`*int`的基类型就是`int`
    - 使用`&`符号获取变量的地址，因此`&`叫做**取地址符号**
    - **解引用(dereference)**: 对一个指针类型的变量前加`*`符号，就能对指针指向的变量做修改
    - **二级指针**: 如`**int`，就是一个指向指针的指针，可读性不强，非必要建议不用

## 切片、map
- 切片可以理解为动态的数组，申明方式和数组很像，但是内存结构和数组不一样
    - 数组：`[3]int{0,0,0}`,`[...]int{0,0,0}`；一个数组变量代表整个数组空间
    - 切片：`[]int{}`, `make([]int, n)`；一个切片变量代表一个描述符（header结构），里面存有指向底层数据的指针和长度等元信息
    - 切片会自动扩容，触发扩容后内部元素的地址会发生改变
- map的使用很简单，实现其实很复杂
    - go编译期会对map的操作做处理，呈现出实际的map类型
    - map的设计优化了内存开销，比如设计成一对键值对的地址不是连续的
- map在使用上有几个注意点：
    1. 每次遍历range遍历map，key的顺序都是不同的
    2. map非线程安全，并发读可以，出现并发读写会抛错
    3. 不允许获取map中value的指针（即地址），编译期就会检查
        - 这么设计的原因是因为，map会动态扩容，自动扩容后地址就变了
